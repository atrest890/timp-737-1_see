# **timp-737-1_see**
Репозиторий для практических работ по ТиМП 2019 г. ТУСУР

## **Практическая работа №1. Вводное занятие**

### **737-1_see-1-1.c**
Написать программу, печатающую в stdout фразу "Hello, World!" на отдельной строке.

### **737-1_see-1-2.c**
Написать программу, принимающую на вход два числа, разделённые пробелом, и суммирующую их. Ввод чисел производить из stdin, вывод результата - в stdout. Вводимые числа не превосходят по модулю 2147483647.

### **737-1_see-1-3.c**
Написать программу, принимающую на вход числа x и y, разделённые пробелом, и вычисляющую x в степени y. Ввод чисел производить из stdin, вывод результата - в stdout. Вводимые числа не превосходят по модулю 2147483647. Реализовывать возведение в степень через цикл/рекурсию не допускается.


## **Практическая работы №2. Однопроходные алгоритмы** 
### **737-1_see-2-1.c - Неубывающая последовательность (вариант 10)**
На вход подается число <a href="https://www.codecogs.com/eqnedit.php?latex=n&space;\in&space;\mathbb{N}&space;:&space;n&space;\leq&space;2147483647" target="_blank"><img src="https://latex.codecogs.com/png.latex?n&space;\in&space;\mathbb{N}&space;:&space;n&space;\leq&space;2147483647" title="n \in \mathbb{N} : n \leq 2147483647" /></a>, а также n чисел <a href="https://www.codecogs.com/eqnedit.php?latex=x_{i}&space;\in&space;\mathbb{Z}&space;:&space;\left&space;|&space;x_{i}&space;\right&space;|&space;\leq&space;2147483647" target="_blank"><img src="https://latex.codecogs.com/png.latex?x_{i}&space;\in&space;\mathbb{Z}&space;:&space;\left&space;|&space;x_{i}&space;\right&space;|&space;\leq&space;2147483647" title="x_{i} \in \mathbb{Z} : \left | x_{i} \right | \leq 2147483647" /></a> для любого целого i от 1 до n. Вывести 1, если <a href="https://www.codecogs.com/eqnedit.php?latex=x_{i}&space;\le&space;x_{i&plus;1}" target="_blank"><img src="https://latex.codecogs.com/png.latex?x_{i}&space;\le&space;x_{i&plus;1}" title="x_{i} \le x_{i+1}" /></a> для любого целого iот 1 до n-1, иначе вывести 0.

### **737-1_see-2-2.c - Разность сумм нечетных и четных кубов (вариант 16)**
На вход подается число <a href="https://www.codecogs.com/eqnedit.php?latex=n&space;\in&space;\mathbb{N}&space;:&space;n&space;\leq&space;2147483647" target="_blank"><img src="https://latex.codecogs.com/png.latex?n&space;\in&space;\mathbb{N}&space;:&space;n&space;\leq&space;2147483647" title="n \in \mathbb{N} : n \leq 2147483647" /></a>, а также n чисел <a href="https://www.codecogs.com/eqnedit.php?latex=x_{i}&space;\in&space;\mathbb{Z}&space;:&space;\left&space;|&space;x_{i}&space;\right&space;|&space;\leq&space;2147483647" target="_blank"><img src="https://latex.codecogs.com/png.latex?x_{i}&space;\in&space;\mathbb{Z}&space;:&space;\left&space;|&space;x_{i}&space;\right&space;|&space;\leq&space;2147483647" title="x_{i} \in \mathbb{Z} : \left | x_{i} \right | \leq 2147483647" /></a> для любого целого i от 1 до n. Вывести значение <a href="https://www.codecogs.com/eqnedit.php?latex=\sum_{i=1}^{n}&space;(-1)^{i&plus;1}&space;\cdot&space;x^{3}_{i}" target="_blank"><img src="https://latex.codecogs.com/png.latex?\sum_{i=1}^{n}&space;(-1)^{i&plus;1}&space;\cdot&space;x^{3}_{i}" title="\sum_{i=1}^{n} (-1)^{i+1} \cdot x^{3}_{i}" /></a>.

## **Практическая работа №3. Односвязные и двусвязные списки**
### **737-1_see-3-1.c - Односвязный список**
Односвязный список - динамическая структура данных, состоящая из узлов, каждый из которых содержит как собственно данные, так
и ссылку на следующий узел списка. Список задается двумя ссылками на его узлы: начальный и конечный. Ниже представлена структура, описывающая узел в односвязном списке:  
```c
struct node
{
  int value;
  struct node *next;
};
```
Необходимо реализовать функции для работы с односвязным
списком:
```c
// инициализация пустого списка
void init(list* l);
//удалить все элементы из списка
void clear(list* l);
// проверка на пустоту списка
int isEmpty(list* l)
// поиск элемента по значению. вернуть NULL если элемент н
е найден
node* find(list* l, int value);
// вставка значения в конец списка, вернуть 0 если успешно
int push_back(list* l, int value);
// вставка значения в начало списка, вернуть 0 если успешн
о
int push_front(list* l, int value);
// вставка значения после указанного узла, вернуть 0 если
успешно
int insertAfter(node* n, int value);
// удалить первый элемент из списка с указанным значением,
вернуть 0 если успешно
int remove(list* l, int value);
// вывести все значения из списка в прямом порядке, через
пробел, после окончания вывода перейти на новую строку
void print(list* l);
```

Используя реализованные функции реализовать программу которая:
1. считать количество элементов
 ∈ N, 0 < ≤ 2147483647;
2. создать пустой список, считать n элементов ai, |ai| ≤
2147483647 и занести их в список;
3. вывести содержимое списка используя функцию print;
4. считать k1, k2, k3 |ki| ≤ 2147483647 и вывести ‘1’ если в
списке существует элемент с таким значением. ‘0’ если нет.
перейти на новую строку.
5. считать m, |m| ≤ 2147483647 и вставить его в конец списка;
6. вывести содержимое списка используя функцию print;
7. считать t, |t| ≤ 2147483647 и вставить его в начало списка;
8. вывести содержимое списка используя функцию print;
9. считать j, 0 < j ≤ 2147483647 и x, |x| ≤ 2147483647 и вставить
значение x после j-ого элемента списка;
10. вывести содержимое списка используя функцию print;
11. считать z, |z| ≤ 2147483647 и удалить первый элемент
хранящий значение z из списка;
12. вывести содержимое списка используя функцию print;
13. очистить список.

Пример входных/выходных данных:

| input   | output       |
|---------|--------------|
|5        |1 2 3 2 4     |
|1 2 3 2 4|101           |
|2 5 1    |1 2 3 2 4 5   |
|7        |7 1 2 3 2 4 5 |
|3 0      |7 1 0 3 2 4 5 |
|2        |              |

### **737-1_see-3-2.c - Двусвязный список**
Двусвязный список - динамическая структура данных, состоящая из узлов, каждый из которых содержит как собственно данные, так и ссылки на следующий и предыдущий узлы списка. Ниже представлена структура, описывающая узел в двусвязном списке:
```c
struct node
{
  int value;
  struct node *next;
  struct node *prev;
};
```

Необходимо реализовать функции для работы с двусвязным
списком:
```c
// инициализация пустого списка
void init(list* l);
//удалить все элементы из списка
void clear(list* l);

// проверка на пустоту списка
int isEmpty(list* l);

// поиск элемента по значению. вернуть NULL если элемент не найден
node* find(list* l, int value);

// вставка значения в конец списка, вернуть 0 если успешно
int push_back(list* l, int value);

// вставка значения в начало списка, вернуть 0 если успешно
int push_front(list* l, int value);

// вставка значения после указанного узла, вернуть 0 еслиуспешно
int insertAfter(node* n, int value);

// вставка значения перед указанным узлом, вернуть 0 если успешно
int insertBefore(node* n, int value);

// удалить первый элемент из списка с указанным значением,вернуть 0 если успешно
int removeFirst(list* l, int value);

// удалить последний элемент из списка с указанным значением, вернуть 0 если //успешно
int removeLast(list* l, int value);

// вывести все значения из списка в прямом порядке, через
//пробел, после окончания вывода перейти на новую строку
void print(list* l);

// вывести все значения из списка в обратном порядке, через пробел, после //окончания вывода перейти на новую строку
void print_invers(list* l);

```

Используя реализованные функции реализовать программу которая:
1. считать количество элементов
 ∈ N, 0 < ≤ 2147483647;
2. создать пустой список, считать n элементов ai, |ai| ≤
2147483647 и занести их в список;
3. вывести содержимое списка используя функцию print;
4. считать k1, k2, k3 |ki| ≤ 2147483647 и вывести ‘1’ если в
списке существует элемент с таким значением. ‘0’ если нет.
перейти на новую строку.
5. считать m, |m| ≤ 2147483647 и вставить его в конец списка;
6. вывести содержимое списка используя функцию print_invers;
7. считать t, |t| ≤ 2147483647 и вставить его в начало списка;
8. вывести содержимое списка используя функцию print;
9. считать j, 0 < j ≤ 2147483647 и x, |x| ≤ 2147483647 и вставить
значение x после j-ого элемента списка;
10. вывести содержимое списка используя функцию print_invers;
11. считать u, 0 < u ≤ 2147483647 и y, |y| ≤ 2147483647 и
вставить значение y перед u-ым элементом списка;
12. вывести содержимое списка используя функцию print;
13. считать z, |z| ≤ 2147483647 и удалить первый элемент
хранящий значение z из списка;
14. вывести содержимое списка используя функцию print_invers;
15. считать r, |r| ≤ 2147483647 и удалить последний элемент
хранящий значение r из списка;
16. вывести содержимое списка используя функцию print;
17. очистить список.


Пример входных/выходных данных:

| input   | output       |
|---------|--------------|
|5        |1 2 3 2 4     |
|1 2 3 2 4|101           |
|2 5 1    |1 4 2 3 2 1  |
|1        |7 1 2 3 2 4 1 |
|7        |1 4 2 3 0 2 1 7 |
|3 0      |7 1 2 0 8 3 2 4 1|
|5 8      |1 4 2 3 8 0 1 7 |
|2        |7 1 0 8 3 2 4   |


## **Практическая работа №4. Бинарные деревья поиска**
### **737-1_see-4-1.c**
Необходимо реализовать структуры данных и функции для работы с
бинарным деревом поиска:
```c
/* структура для хранения узла дерева. Необходимо хранить
ссылки на потомков, предка и некоторое значение (целое чис
ло) */

struct node;
/* структура для хранения дерева. хранит ссылку на корень
дерева и количество элементов в дереве */
struct tree;

// инициализация пустого дерева
void init(tree* t);

//удалить все элементы из дерева
void clear(tree* t);

/* поиск элемента по значению. вернуть 0 если элемент найден и ссылку на найденный элемент в переменную n если n !=
NULL. в случае если элемент не найден вернуть 1
*/
int find(tree* t, int value, node* n);

/* вставка значения в дерево. вернуть 0 если вставка выпол
нена успешна,
1 если элемент уже существует
2 если не удалось выделить память для нового элемента
*/
int insert(tree* t, int value);

/* удалить элемент из дерева. вернуть 0 если элемент был у
дален и 1 если нет элемента с указанным значением */
int remove(tree* t, int value);

/* удалить минимальный элемент из поддерева, корнем которо
го является n. вернуть значение удаленного элемента */
int removeMin(node* n);

/* выполнить правое вращение поддерева, корнем которого яв
ляется n. вернуть 0 при успещшно выполнение операции и 1 в
случае если вращение невозможно */
int rotateRight(node *n);

/* выполнить левое вращение поддерева, корнем которого явл
яется n. вернуть 0 при успещшно выполнение операции и 1 в
случае если вращение невозможно */
int rotateLeft(node *n);

/* вывести все значения из поддерева корнем которого являе
тся n по уровнем, начиная с корня. каждый уровень выводитс
я на своей строке. элементы в строке разделяются пробелом.
если на указанном месте нет элемента, заменить его значен
ием '_'. Если дерево пусто вывести '-' */
void print(node* n);

// вывести все значения дерева t, аналогично функции print
void printTree(tree* t);

```
Используя реализованные функции реализовать программу которая:
1. создать пустое дерево, считать 4 элементов ai, |a i| ≤
2147483647 и занести их в дерево;
2. вывести дерево используя функцию printTree;

| input | output |
|-------|--------|
|2 1 3 2 | 2     |
|        | 1 3   |      

3. считать 3 элементов ai, |ai| ≤ 2147483647 и занести их в
дерево;
4. вывести дерево используя функцию printTree;

| input | output |
|-------|--------|
|0 4 5  | 2      |
|       | 1 3    |
|       | 0 _ _ 4|
|       | _ _ _ _ _ _ _ 5 |

5. считать m1, |m1| ≤ 2147483647 и найти элемент с заданным
значением в дереве. вывести через пробел значение предка
и потомков найденного элемента. если элемент не найден,
вывести "_", если нет значений предка или потомков вывести
’’ вместо таких значений.

| input | output |
|-------|--------|
|3      | 2 _ 4  |

6. считать m2, |m2| ≤ 2147483647 и найти элемент с заданным
значением в дереве. вывести через пробел значение предка
и потомков найденного элемента. если элемент не найден,
вывести ‘-’, если нет значений предка или потомков вывести
‘_’ вместо таких значений.

| input | output |
|-------|--------|
|6      |-       |

7. считать m3, |m3| ≤ 2147483647 и удалить из дерева элемент с
заданным значением
8. вывести деревео используя printTree


| input | output |
|-------|--------|
|2      |3       |
|       |1 4     |
|       |0 _ _ 5 |

9. выполнять левый поворот дерева относительно корня, пока
это возможно.
10. вывести дерево используя команду printTree

| input | output |
|-------|--------|
|       |5       | 
|       |4 _     |
|       |3 _ _ _ |
|       |1 _ _ _ _ _ _ _ |
|       |0 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ |

11. выполнять правый поворот дерева относительно корня, пока
это возможно.
12. вывести дерево используя команду printTree

| input | output |
|-------|--------|
|       |0       | 
|       |_ 1     |
|       |_ _ _ 3|
|       | _ _ _ _ _ _ _ 4|
|       |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 5|

13. вывести на экран количество элементов в дереве
14. очистить дерево
15. вывести дерево на экран используя printTree


## **Практическая работа №5. Обходы дерева**
### **737-1_see-5-1.c - Обход дерева в ширину**
Реализовать обход дерева в ширину.
1. считать с входного потока 7 чисел и занести их в дерево.
2. Вывести все значения вершин дерева через пробел в порядке
их посещения. 

Пример входных/выходных данных:

| input | output |
|-------|--------|
|5 3 7 2 4 6 8 | 5 3 7 2 4 6 8 |

### **737-1_see-5-2.c - Прямой обход дерева**
Реализовать прямой обход дерева. Использование рекурсии
недопускается!
1. считать с входного потока 7 чисел и занести их в дерево.
2. Вывести все значения вершин дерева через пробел в порядке
их посещения.


Пример входных/выходных данных:
| input | output |
|-------|--------|
|5 3 7 2 4 6 8 | 5 3 2 4 7 6 8 |



### **737-1_see-5-3.c - Обратный обход в дерево**
Реализовать обратный обход дерева с использованием рекурсии.
1. считать с входного потока 7 чисел и занести их в дерево.
2. Вывести все значения вершин дерева через пробел в порядке
их посещения.

Пример входных/выходных данных:

| input | output |
|-------|--------|
|5 3 7 2 4 6 8 | 2 4 3 6 8 7 5 |


## **Практическая работа №6. Сортировки (расческой и Шелла)**
### **737-1_see-6-1.c - Сортировка расческой**
Считать количество элементов n.  
Считать n целочисленных элементов.  
Отсортировать полученный массив сортировкой расчёской.  
Вывести отсортированный массив на экран через пробел.  


### **737-1_see-6-2.c - Сортировка Шелла**
Считать количество элементов n.  
Считать n целочисленных элементов.  
Отсортировать полученный массив сортировкой Шелла.  
Вывести отсортированный массив на экран через пробел.  


## **Практическая работа №7. Сортировки (быстрая и пирамидальная)**
### **737-1_see-7-1.c - Быстрая сортировка**
Считать количество элементов n.  
Считать n целочисленных элементов.  
Отсортировать полученный массив Быстрой сортировкой.  
Вывести отсортированный массив на экран через пробел. (после
чего перейти на новую строку)  


### **737-1_see-7-2.c - Пирамидальная сортировка**
Считать количество элементов n.  
Считать n целочисленных элементов.  
Отсортировать полученный массив Пирамидальной сортировкой.  
Вывести отсортированный массив на экран через пробел. (после
чего перейти на новую строку)
